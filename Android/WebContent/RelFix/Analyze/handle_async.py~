#!/usr/bin/python
#coding=utf-8

##
# Author: Jierui Liu (liujierui@gmail.com)
# Date: Oct 8th, 2015
# Description: Handle asynchronous callbacks.
#

import os
import re

from track_reg import *
from constant import *
from track_act import *

##
# Class: Scan smali files to build a graph for handling asynchronous callbacks.
#
class AsyncGraph(object):
    ##
    # function: Constructor.
    # @param rfcg: The rFCG
    # @param act_list: All activities in the app
    # @param ser_list: All services in the app
    # @param smali_folder: The Smali folder path
    #
    def __init__(self, rfcg, act_list, ser_list, smali_folder):
        if not hasattr(self, '_AsyncGraph__afcg'):
            self.__rfcg = rfcg
            self.__act_list = act_list
            self.__ser_list = ser_list
            self.__smali_folder = smali_folder
            self.__afcg = {}
            self.__rafcg = {}

            self.__done = False
            while not self.__done:
                self.__done = True
                self.__obtain_afcg('')

    ##
    # function: This method for creating a Singleton.
    #
    def __new__(cls, rfcg, act_list, ser_list, smali_folder):
        if not hasattr(cls, 'instance'):
            cls.instance = object.__new__(cls, rfcg, act_list, ser_list, smali_folder)

        return cls.instance

    ##
    # function: Judge if we have found a component.
    # @param reg_type: The object type of the value in the register 
    # @return: True or False
    #
    def __not_a_component(self, reg_type):
        if reg_type.split('/')[0].find('android') >= 0:
            return True
        else:
            class_name = reg_type.rstrip(';').lstrip('L')

            if class_name in self.__act_list or class_name in self.__ser_list:
                return False
            else:
                return True

    ##
    # function: Obtain the aFCG from scaning smali files for handling asynchronous callbacks.
    # @param file_path: The target file path
    #
    def __obtain_afcg(self, file_path):
        # Don't scan the Android package
        if 'android' == file_path:
            return

        if '' == file_path:
            target_path = self.__smali_folder
        else:
            target_path = self.__smali_folder + os.path.sep + file_path

        if os.path.exists(target_path):
            if os.path.isdir(target_path):
                for item in os.listdir(target_path):
                    if '' == file_path:
                        self.__obtain_afcg(item)
                    else:
                        self.__obtain_afcg(file_path + os.path.sep + item)
            else:
                # Get each lines of the smali file
                smali_file = open(target_path, 'r')
                file_contents = []
                try:
                    file_contents = smali_file.readlines()
                finally:
                    smali_file.close()

                for index, each_line in enumerate(file_contents):
                    find_registration = False

                    # setOnClickListener(
                    if each_line.find('setOnClickListener(') >= 0:
                        find_registration = True

                        caller_reg = each_line.split('{')[1].split('}')[0].split(',')[0].strip(' ')
                        listener_reg = each_line.split('{')[1].split('}')[0].split(',')[1].strip(' ')
                        listener = self.__track_reg_find_class(file_contents, index, listener_reg)
                        if not '' == listener:
                            listener = listener + '->onClick(Landroid/view/View;)V'
                        component = self.__track_reg_find_class(file_contents, index, caller_reg)
                        com_type = 's'
                    # Landroid/hardware/Camera;->takePicture(
                    elif each_line.find('Landroid/hardware/Camera;->takePicture(') >= 0:
                        find_registration = True

                        listener_reg = each_line.split('{')[1].split('}')[0].split(',')[3].strip(' ')
                        listener = self.__track_reg_find_class(file_contents, index, listener_reg)
                        if not '' == listener:
                            listener = listener + '->onPictureTaken([BLandroid/hardware/Camera;)V'
                        component = self.__FCG_find_class(file_contents, index, listener)
                        com_type = 'a'

                    if find_registration and not 0 == len(component) and not '' == listener:
                        if 'a' == com_type:
                            for each_com in component:
                                if not each_com in self.__afcg:
                                    self.__afcg[each_com] = []
                                if not listener in self.__afcg[each_com]:
                                    self.__afcg[each_com].append(listener)

                            if not listener in self.__rafcg:
                                self.__rafcg[listener] = []
                            for each_com in component:
                                if not each_com in self.__rafcg[listener]:
                                    self.__rafcg[listener].append(each_com)
                        elif 's' == com_type:
                            if not component in self.__afcg:
                                self.__afcg[component] = []
                            if not listener in self.__afcg[component]:
                                self.__afcg[component].append(listener)

                            if not listener in self.__rafcg:
                                self.__rafcg[listener] = []
                            if not component in self.__rafcg[listener]:
                                self.__rafcg[listener].append(component)

    ##
    # function: Find the activity class by using FCG.
    # @param contents: The smali file contents
    # @param index: The current index of the contents
    # @param listener: The listener callback method
    # @return: The class's type
    #
    def __FCG_find_class(self, contents, index, listener):
        while contents[index].find('.method') < 0:
            index -= 1

        func_name = contents[0].strip(' \n').split(' ')[-1] + '->' + contents[index].strip(' \n').split(' ')[-1]
        track_list = [[func_name, 0]]
        while need_more_track(track_list, self.__act_list, self.__ser_list):
            for i, each in enumerate(track_list):
                if listener == each[0]:
                    del(track_list[i])
                    i -= 1

            for i in range(len(track_list)):
                if 0 == track_list[i][1]:
                    if 0 == len(self.__rfcg[track_list[i][0]]):
                        if track_list[i][0] in self.__rafcg:
                            for item in self.__rafcg[track_list[i][0]]:
                                track_list.append([item, 1])
                            del(track_list[i])
                            i -= 1
                        else:
                            track_list[i][1] = 3
                    else:
                        for new_func in self.__rfcg[track_list[i][0]]:
                            track_list.append([new_func, 2])
                        del(track_list[i])
                        i -= 1

            for each_func in track_list:
                if 2 == each_func[1]:
                    each_func[1] = 0

        result = []
        for each in track_list:
            if not 1 == each[1]:
                self.__done = False
                return result

            result.append(each[0])
        return result

    ##
    # function: Track a field variable.
    # @param contents: The smali file contents.
    # @param index: The current index of the contents
    # @param field: The variable name
    # @return: The variable's type
    #
    def __track_field(self, contents, index, field):
        index = next_valid_index(contents, index, 1)
        sen_split = re.split('[ ,{}]', contents[index].strip(' \n'))
        while '' in sen_split:
            sen_split.remove('')
        while not field == sen_split[-1]:
            index = next_valid_index(contents, index, 1)
            sen_split = re.split('[ ,{}]', contents[index].strip(' \n'))
            while '' in sen_split:
                sen_split.remove('')

        if contents[index].find('put-object') >= 0:
            reg_name = sen_split[1]
            return self.__track_reg_find_class(contents, index, reg_name)
        else:
            print('---> ERROR: track_field => backtrack failed' + contents[index])

    ##
    # function: Find the activity and listener class by tracking registers.
    # @param contents: The smali file contents
    # @param index: The current index of the contents
    # @param reg: The register name
    # @return: The class's type
    #
    def __track_reg_find_class(self, contents, index, reg):
        if reg.find('p') >= 0:
            method_index = index
            while contents[method_index].find('.method') < 0:
                method_index -= 1

            param_list = get_param_seq(contents[method_index].split('(')[1].split(')')[0])
            if contents[method_index].find('static') >= 0:
                reg_type = param_list[int(reg.strip('p'))]
            else:
                if 'p0' == reg:
                    reg_type = contents[0].strip(' \n').split(' ')[-1]
                else:
                    reg_type = param_list[int(reg.strip('p')) - 1]
        else: 
            index = next_valid_index(contents, index, 1)
            sen_split = re.split('[ ,{}]', contents[index].strip(' \n'))
            while '' in sen_split:
                sen_split.remove('')
            while '.' == sen_split[0][0] or sen_split[0].find('check-cast') >= 0 or sen_split[0].find('invoke-') >= 0 or not reg == sen_split[1]:
                index = next_valid_index(contents, index, 1)
                sen_split = re.split('[ ,{}]', contents[index].strip(' \n'))
                while '' in sen_split:
                    sen_split.remove('')
               
            if contents[index].find('new-instance') >= 0:
                reg_type = contents[index].strip(' \n').split(',')[-1].strip(' ')
            elif contents[index].find('get-object') >= 0:
                reg_type = contents[index].strip(' \n').split(':')[1]
                if reg_type.split('/')[0].find('android') >= 0:
                    field = contents[index].strip(' \n').split(' ')[-1]
                    reg_type = self.__track_field(contents, index, field)
            elif contents[index].find('move-result') >= 0:
                index = next_valid_index(contents, index, 1)
                sen_split = re.split('[ ,{}]', contents[index].strip(' \n'))
                while '' in sen_split:
                    sen_split.remove('')
                if contents[index].find('findViewById') >= 0:
                    reg_name = sen_split[1]
                    reg_type = get_reg_type(0, contents[index])
                    if reg_type.split('/')[0].find('android') >= 0:
                        reg_type = self.__track_reg_find_class(contents, index, reg_name)
                else:
                    print('---> ERROR: move-result => backtrack unknown operation')
            else:
                print('---> ERROR: asynchrony => backtrack failed: ' + contents[index])
                return ''

        return reg_type

    ##
    # function: Other objects get the aFCG from this method.
    # @return: The dictionary storing the aFCG information 
    #
    def get_aFCG(self):
        return self.__afcg

    ##
    # function: Other objects get the raFCG from this method.
    # @return: The dictionary storing the raFCG information 
    #
    def get_raFCG(self):
        return self.__rafcg

