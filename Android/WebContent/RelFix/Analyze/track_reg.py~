#!/usr/bin/pyhon
#coding=utf-8

##
# Author: Jierui Liu (liujierui@gmail.com)
# Date: Sep 15th, 2015
# Description: Identify registers an applying method uses and save the valuse to the corresponding fields.
#

import os
import sys

from add_id_var import *

##
# function: Find the next valid sentence.
# @param contents: Smali file's contents
# @param index: Current index
# @param direction: Upward or downward (1 for up, 2 for down)
#
def next_valid_index(contents, index, direction):
    temp_index = 1
    if 1 == direction:
        while contents[index - temp_index].isspace():
            temp_index += 1
        return index - temp_index
    if 2 == direction:
        while contents[index + temp_index].isspace():
            temp_index += 1
        return index + temp_index

##
# function: Find all parameters of a method.
# @param param_str: The string containing paramters infomation
# @return: A sequence of paramters
#
def get_param_seq(param_str):
    result = []

    index = 0
    start_index = 0
    is_end = True
    is_ref = False
    while index < len(param_str):
        if is_end:
            start_index = index
            is_end = False

        if 'L' == param_str[index] and not is_ref:
            is_ref = True
            index += 1
        elif not '[' == param_str[index] and not is_ref:
            is_end = True
            result.append(param_str[start_index:index+1])
            index += 1
        elif ';' == param_str[index]:
            is_end = True
            is_ref = False
            result.append(param_str[start_index:index+1])
            index += 1
        else:
            index += 1

    return result

##
# function: Find the variable type stored in the specific register.
# @param reg_position: The register position
# @param content_str: The string to be analyzed
# @return: The varibale type
#
def get_reg_type(reg_position, content_str):
    method_str = content_str.strip(' \n').split(' ')[-1]
    if 0 == reg_position:
        return method_str.split('->')[0]
    else:
        param_seq = get_param_seq(method_str.split('(')[1].split(')')[0])
        return param_seq[reg_position - 1]

##
# function: Track registers an applying method uses
# @param smali_folder: Smali folder path
# @param res_info: The leaked resource or the release info
# @param flag: Distinguish different resources in a funciton
# @param res_type: The type of the parameter res_info
# @return: The leaked resource's identity
#
def track_registers(smali_folder, res_info, flag, res_type):
    reg_need_track = []
    
    if 'LeakedRes' == res_type:
        reg_need_track.append(0)
        for each in res_info.get_arg_from():
            reg_need_track.append(int(each))

        target_op = res_info.get_apply_func()

    if 'RelInfo' == res_type:
        target_op = res_info.get_release_func()

    res_identity = []

    smali_file = open(smali_folder + os.path.sep + res_info.get_func_path(), 'r')
    try:
        smali_file_contents = smali_file.readlines()
    finally:
        smali_file.close()

    for index, content in enumerate(smali_file_contents):
        if content.find('.method') >= 0 and content.find(res_info.get_func_name()) >= 0:
            temp_index = index + 1
            while not 0 == flag:
                while smali_file_contents[temp_index].find(target_op) < 0:
                    temp_index += 1

                flag -= 1
                temp_index += 1

            temp_index -= 1

            method_str = res_info.get_func_name().split('(')[0]
            target_op_class = target_op.split(os.path.sep)[-1].split(';->')[0]
            target_op_str = target_op.split(os.path.sep)[-1].split(';->')[1].split('(')[0]

            if 'RelInfo' == res_type:
                reg_str = smali_file_contents[temp_index].split('{')[1].split('}')[0]

                if '' == reg_str:
                    reg_num = 0
                else:
                    reg_num = len(reg_str.split(','))

                for i in range(reg_num):
                    reg_need_track.append(i)

            # The static pattern like 'mCamera = Camera.open();'.
            if smali_file_contents[temp_index].find('invoke-static') >= 0:
                if 'RelInfo' == res_type:
                    print('---> ERROR: static => shouldn\'t be static')

                for reg in reg_need_track:
                    reg_temp_index = temp_index

                    if 0 == reg:
                        return_type = smali_file_contents[temp_index].strip(' \n').split(')')[1]
                        field_id = 'id_' + method_str + '_' + target_op_class + '_' + target_op_str.strip('<>') + '_' + str(flag) + '_' + str(reg)

                        add_static_field(smali_file_contents, field_id, return_type)
                        res_identity.append(field_id + ':' + return_type)

                        reg_temp_index = next_valid_index(smali_file_contents, reg_temp_index, 2)
                        if smali_file_contents[reg_temp_index].find('move-result') >= 0:
                            register = smali_file_contents[reg_temp_index].strip('\n').strip(' ').split(' ')[1]

                            new_sentences = []
                            new_sentences.append('\n')
                            op_arg = register + ', L' + res_info.get_func_path().rstrip('.smali') + ';->' + field_id + ':' + return_type +'\n'
                            add_op_sentence(return_type, new_sentences, 'sput', op_arg)
                            new_sentences.append('\n')

                            save_identity(smali_file_contents, reg_temp_index + 1, new_sentences)
                        else:
                            print('---> ERROR: static => not find \'move-result\'')
                    else:
                        print('---> ERRPR: static => more than one identity')
            # Other patterns.
            elif smali_file_contents[temp_index].find('invoke-virtual') >= 0 \
                    or smali_file_contents[temp_index].find('invoke-direct') >= 0:
                register_str = smali_file_contents[temp_index].split('{')[1].split('}')[0]
                for reg in reg_need_track:
                    track_reg = register_str.split(',')[reg].strip(' ')
                    reg_type = get_reg_type(reg, smali_file_contents[temp_index])
                    field_id = 'id_' + method_str + '_' + target_op_class + '_' + target_op_str.strip('<>') + '_' + str(flag) + '_' + str(reg)

                    add_static_field(smali_file_contents, field_id, reg_type)
                    res_identity.append(field_id + ':' + reg_type)

                    new_sentences = []
                    new_sentences.append('\n')
                    op_arg = track_reg + ', L' + res_info.get_func_path().rstrip('.smali') + ';->' + field_id + ':' + reg_type +'\n'
                    add_op_sentence(reg_type, new_sentences, 'sput', op_arg)
                    new_sentences.append('\n')

                    save_identity(smali_file_contents, temp_index + 1, new_sentences)
            else:
                print('---> ERROR: ' + target_op + ' \'invoke-\' type error')

            break

    smali_file = open(smali_folder + os.path.sep + res_info.get_func_path(), 'w')
    try:
        smali_file.writelines(smali_file_contents)
    finally:
        smali_file.close()

    return res_identity
                      
